<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lock-free on What a blog</title><link>https://daiakushi.github.io/tags/lock-free/</link><description>Recent content in lock-free on What a blog</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Thu, 18 Aug 2022 09:00:00 +0000</lastBuildDate><atom:link href="https://daiakushi.github.io/tags/lock-free/index.xml" rel="self" type="application/rss+xml"/><item><title>Lock-free programming</title><link>https://daiakushi.github.io/post/2022-08-18-lock-free-programming/</link><pubDate>Thu, 18 Aug 2022 09:00:00 +0000</pubDate><guid>https://daiakushi.github.io/post/2022-08-18-lock-free-programming/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近為了某個專案稍微複習了一下multi-thread的同步控制，除了使用簡單的spin-lock之外，還有更為強大的lockless演算法，如同前輩們所告誡的，看起來越是酷炫的東西，背後隱藏的陷阱也越多，本文是讀完&lt;a href="http://msdn.microsoft.com/en-us/library/ee418650%28v=vs.85%29.aspx">Lockless Programming Considerations for Xbox 360 and Microsoft Windows&lt;/a>所寫的心得，好文章當然得作點筆記以供日後參考&lt;/p></description></item></channel></rss>